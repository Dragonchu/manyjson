"use strict";const c=require("electron"),f=require("path"),n=require("fs"),m=process.env.NODE_ENV==="development";function i(s,...e){console.log(`[INFO] ${new Date().toISOString()} - ${s}`,...e)}function o(s,e){console.error(`[ERROR] ${new Date().toISOString()} - ${s}`,e)}function u(s,...e){m&&console.log(`[DEBUG] ${new Date().toISOString()} - ${s}`,...e)}function v(s){if(!s||typeof s!="string")return{isValid:!1,error:"Filename is required and must be a string"};const e=s.trim();return e?e.includes("..")||e.includes("/")||e.includes("\\")?{isValid:!1,error:"Filename cannot contain path separators or relative path references"}:/[<>:"|?*\x00-\x1f]/.test(e)?{isValid:!1,error:"Filename contains invalid characters"}:Buffer.byteLength(e,"utf8")>255?{isValid:!1,error:"Filename is too long"}:/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i.test(e)?{isValid:!1,error:"Filename uses a reserved name"}:{isValid:!0}:{isValid:!1,error:"Filename cannot be empty"}}async function D(s=3){const e=O();for(let r=1;r<=s;r++)try{u(`Ensuring config directory exists (attempt ${r}/${s}):`,e);try{await n.promises.access(e,n.constants.F_OK),u("Config directory already exists")}catch{i("Creating config directory:",e),await n.promises.mkdir(e,{recursive:!0}),i("Config directory created successfully")}try{return await n.promises.access(e,n.constants.W_OK),u("Config directory is writable"),e}catch(t){throw o("Config directory is not writable",t),new Error(`Config directory is not writable: ${e}`)}}catch(t){if(o(`Failed to create or access config directory (attempt ${r}/${s})`,t),r===s)throw t;await new Promise(a=>setTimeout(a,100*r))}throw new Error("Failed to ensure config directory after all retries")}function h(){const s=new c.BrowserWindow({width:1200,height:800,minWidth:1e3,minHeight:700,title:"ManyJson - JSON Schema Manager",backgroundColor:c.nativeTheme.shouldUseDarkColors?"#0a0a0a":"#ffffff",webPreferences:{preload:f.join(__dirname,"preload.js"),contextIsolation:!0,sandbox:!0,nodeIntegration:!1}});if(m)s.loadURL("http://localhost:5173"),s.webContents.openDevTools();else{const e=f.join(__dirname,"../dist/index.html");i("Loading HTML file from:",e),s.loadFile(e).catch(r=>{o("Failed to load HTML file",{htmlPath:e,error:r}),s.webContents.openDevTools()})}return s}function O(){const s=c.app.getPath("userData"),e=f.join(s,"schemas");return u("Config directory path:",e),e}async function g(){return D()}c.ipcMain.handle("read-file-sync",async(s,e)=>{i("IPC: read-file-sync called",{filename:e});try{const r=await n.promises.readFile(e,"utf-8"),t=JSON.parse(r);return i("File read successfully",{filename:e,contentLength:r.length}),t}catch(r){throw o("Failed to read file",{filename:e,error:r}),r}});c.ipcMain.handle("write-json-file",async(s,e,r)=>{i("write-json-file requested",{filePath:e,contentLength:r.length});try{const t=f.join(e,"..");try{await n.promises.access(t,n.constants.W_OK),u("Target directory is writable:",t)}catch(a){throw o("Target directory is not writable",{directory:t,error:a}),new Error(`Directory is not writable: ${t}`)}return await n.promises.writeFile(e,r,"utf8"),i("File written successfully:",e),{success:!0}}catch(t){return o("Failed to write file",{filePath:e,error:t instanceof Error?t.message:t,stack:t instanceof Error?t.stack:void 0}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});c.ipcMain.handle("get-config-directory",async()=>{i("get-config-directory requested");try{const s=await g();return i("Config directory ready:",s),{success:!0,path:s}}catch(s){return o("Failed to get config directory",s),{success:!1,error:s instanceof Error?s.message:"Unknown error"}}});c.ipcMain.handle("write-config-file",async(s,e,r)=>{i("write-config-file requested",{fileName:e,contentLength:r.length});try{const t=v(e);if(!t.isValid)return o("Invalid filename provided",{fileName:e,error:t.error}),{success:!1,error:t.error};if(typeof r!="string")return o("Invalid content type",{contentType:typeof r}),{success:!1,error:"Content must be a string"};if(r.length>10*1024*1024)return o("Content too large",{contentLength:r.length}),{success:!1,error:"Content is too large (maximum 10MB)"};const a=await g(),l=f.join(a,e);u("Writing config file",{configDir:a,fileName:e,filePath:l});try{await n.promises.access(l,n.constants.F_OK),u("File already exists, checking write permissions"),await n.promises.access(l,n.constants.W_OK)}catch{u("File does not exist, will create new file")}const p=`${l}.tmp`;try{await n.promises.writeFile(p,r,"utf8"),await n.promises.rename(p,l),i("Config file written successfully",{filePath:l,size:r.length})}catch(d){try{await n.promises.unlink(p)}catch{u("No temp file to clean up")}throw d}return{success:!0,filePath:l}}catch(t){return o("Failed to write config file",{fileName:e,error:t instanceof Error?t.message:t,stack:t instanceof Error?t.stack:void 0,code:t==null?void 0:t.code,errno:t==null?void 0:t.errno,syscall:t==null?void 0:t.syscall,path:t==null?void 0:t.path}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});c.ipcMain.handle("list-config-files",async()=>{i("list-config-files requested");try{const s=await g();u("Listing files in config directory:",s);const e=await n.promises.readdir(s);u("Found files:",e);const r=e.filter(a=>a.endsWith(".json")&&!a.endsWith(".tmp"));i("Found JSON files:",r);const t=await Promise.all(r.map(async a=>{const l=f.join(s,a);try{const p=await n.promises.readFile(l,"utf8"),d=JSON.parse(p);return u("Successfully read file:",{fileName:a,size:p.length}),{name:a,path:l,content:d}}catch(p){throw o("Failed to read or parse file",{fileName:a,error:p}),p}}));return i("Successfully loaded config files",{count:t.length}),{success:!0,files:t}}catch(s){return o("Failed to list config files",s),{success:!1,error:s instanceof Error?s.message:"Unknown error"}}});c.ipcMain.handle("show-open-dialog",async(s,e)=>{i("show-open-dialog requested",e);try{const r=await c.dialog.showOpenDialog(e);return u("Open dialog result:",r),r}catch(r){return o("Failed to show open dialog",r),{canceled:!0,filePaths:[]}}});c.ipcMain.handle("show-save-dialog",async(s,e)=>{i("show-save-dialog requested",e);try{const r=await c.dialog.showSaveDialog(e);return u("Save dialog result:",r),r}catch(r){return o("Failed to show save dialog",r),{canceled:!0,filePath:void 0}}});c.ipcMain.handle("delete-file",async(s,e)=>{i("delete-file requested",{filePath:e});try{return await n.promises.access(e,n.constants.F_OK),u("File exists, attempting to delete:",e),await n.promises.unlink(e),i("File deleted successfully:",e),{success:!0}}catch(r){return o("Failed to delete file",{filePath:e,error:r instanceof Error?r.message:r,code:r==null?void 0:r.code,errno:r==null?void 0:r.errno}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});c.ipcMain.handle("rename-file",async(s,e,r)=>{i("rename-file requested",{oldPath:e,newPath:r});try{if(!e||!r)return{success:!1,error:"Both oldPath and newPath are required"};if(e===r)return i("rename-file skipped: paths are identical"),{success:!0,filePath:r};const t=f.dirname(e),a=f.dirname(r);if(t!==a)return o("rename-file denied: directory changed",{oldDir:t,newDir:a}),{success:!1,error:"Renaming must stay within the original folder"};try{return await n.promises.access(r,n.constants.F_OK),o("rename-file denied: target already exists",{newPath:r}),{success:!1,error:"A file with the new name already exists"}}catch{}return await n.promises.rename(e,r),i("File renamed successfully",{from:e,to:r}),{success:!0,filePath:r}}catch(t){return o("Failed to rename file",{oldPath:e,newPath:r,error:t}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});c.ipcMain.handle("copy-file",async(s,e,r)=>{console.log("IPC copy-file requested",{filePath:e,newPath:r}),i("copy-file requested",{filePath:e,newPath:r});try{if(!e||!r)return{success:!1,error:"Both filePath and newPath are required"};try{await n.promises.access(e,n.constants.F_OK|n.constants.R_OK)}catch{return o("copy-file denied: source file not accessible",{filePath:e}),{success:!1,error:"Source file does not exist or is not readable"}}if(e===r)return o("copy-file denied: paths are identical"),{success:!1,error:"Cannot copy file to the same location"};const t=f.dirname(e),a=f.dirname(r);if(t!==a)return o("copy-file denied: directory changed",{sourceDir:t,targetDir:a}),{success:!1,error:"Copying must stay within the original folder"};try{return await n.promises.access(r,n.constants.F_OK),o("copy-file denied: target already exists",{newPath:r}),{success:!1,error:"A file with the target name already exists"}}catch{}const l=await n.promises.readFile(e,"utf8");return await n.promises.writeFile(r,l,"utf8"),i("File copied successfully",{from:e,to:r}),{success:!0,filePath:r}}catch(t){return o("Failed to copy file",{filePath:e,newPath:r,error:t}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});c.ipcMain.handle("create-schema-json-directory",async(s,e)=>{i("create-schema-json-directory requested",{schemaName:e});try{const r=await g(),t=f.join(r,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));return await n.promises.mkdir(t,{recursive:!0}),i("Schema JSON directory created/verified:",t),{success:!0,path:t}}catch(r){return o("Failed to create schema JSON directory",{schemaName:e,error:r}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});c.ipcMain.handle("write-schema-json-file",async(s,e,r,t)=>{i("write-schema-json-file requested",{schemaName:e,fileName:r,contentLength:t.length});try{const a=await g(),l=f.join(a,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));await n.promises.mkdir(l,{recursive:!0});const p=r.endsWith(".json")?r:`${r}.json`,d=f.join(l,p);return await n.promises.writeFile(d,t,"utf8"),i("Schema JSON file written successfully:",d),{success:!0,filePath:d}}catch(a){return o("Failed to write schema JSON file",{schemaName:e,fileName:r,error:a}),{success:!1,error:a instanceof Error?a.message:"Unknown error"}}});c.ipcMain.handle("list-schema-json-files",async(s,e)=>{i("list-schema-json-files requested",{schemaName:e});try{const r=await g(),t=f.join(r,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));try{await n.promises.access(t,n.constants.F_OK)}catch{return i("Schema directory does not exist, returning empty list:",t),{success:!0,files:[]}}const l=(await n.promises.readdir(t)).filter(d=>d.endsWith(".json")),p=await Promise.all(l.map(async d=>{const w=f.join(t,d);try{const y=await n.promises.readFile(w,"utf8"),F=JSON.parse(y);return{name:d,path:w,content:F}}catch(y){throw o("Failed to read schema JSON file",{fileName:d,error:y}),y}}));return i("Successfully loaded schema JSON files",{schemaName:e,count:p.length}),{success:!0,files:p}}catch(r){return o("Failed to list schema JSON files",{schemaName:e,error:r}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});c.app.whenReady().then(()=>{i("App is ready, creating main window"),h(),i("System information",{platform:process.platform,arch:process.arch,version:process.version,electronVersion:process.versions.electron,userDataPath:c.app.getPath("userData"),tempPath:c.app.getPath("temp"),homePath:c.app.getPath("home")}),c.app.on("activate",()=>{c.BrowserWindow.getAllWindows().length===0&&(i("Reactivating app, creating new window"),h())})});c.app.on("window-all-closed",()=>{i("All windows closed"),process.platform!=="darwin"&&(i("Quitting app"),c.app.quit())});c.app.on("web-contents-created",(s,e)=>{e.on("new-window",(r,t)=>{r.preventDefault(),o("Blocked new window creation",{url:t})})});

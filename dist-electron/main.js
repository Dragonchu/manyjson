"use strict";const i=require("electron"),g=require("path"),n=require("fs"),m=process.env.NODE_ENV==="development";function o(s,...e){console.log(`[INFO] ${new Date().toISOString()} - ${s}`,...e)}function c(s,e){console.error(`[ERROR] ${new Date().toISOString()} - ${s}`,e)}function f(s,...e){m&&console.log(`[DEBUG] ${new Date().toISOString()} - ${s}`,...e)}function v(s){if(!s||typeof s!="string")return{isValid:!1,error:"Filename is required and must be a string"};const e=s.trim();return e?e.includes("..")||e.includes("/")||e.includes("\\")?{isValid:!1,error:"Filename cannot contain path separators or relative path references"}:/[<>:"|?*\x00-\x1f]/.test(e)?{isValid:!1,error:"Filename contains invalid characters"}:Buffer.byteLength(e,"utf8")>255?{isValid:!1,error:"Filename is too long"}:/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i.test(e)?{isValid:!1,error:"Filename uses a reserved name"}:{isValid:!0}:{isValid:!1,error:"Filename cannot be empty"}}async function j(s=3){const e=D();for(let r=1;r<=s;r++)try{f(`Ensuring config directory exists (attempt ${r}/${s}):`,e);try{await n.promises.access(e,n.constants.F_OK),f("Config directory already exists")}catch{o("Creating config directory:",e),await n.promises.mkdir(e,{recursive:!0}),o("Config directory created successfully")}try{return await n.promises.access(e,n.constants.W_OK),f("Config directory is writable"),e}catch(t){throw c("Config directory is not writable",t),new Error(`Config directory is not writable: ${e}`)}}catch(t){if(c(`Failed to create or access config directory (attempt ${r}/${s})`,t),r===s)throw t;await new Promise(a=>setTimeout(a,100*r))}throw new Error("Failed to ensure config directory after all retries")}function y(){const s=new i.BrowserWindow({width:1200,height:800,minWidth:1e3,minHeight:700,title:"ManyJson - JSON Schema Manager",backgroundColor:i.nativeTheme.shouldUseDarkColors?"#0a0a0a":"#ffffff",webPreferences:{preload:g.join(__dirname,"preload.js"),contextIsolation:!0,sandbox:!0,nodeIntegration:!1}});if(m)s.loadURL("http://localhost:5173"),s.webContents.openDevTools();else{const e=g.join(__dirname,"../dist/index.html");o("Loading HTML file from:",e),s.loadFile(e).catch(r=>{c("Failed to load HTML file",{htmlPath:e,error:r}),s.webContents.openDevTools()})}return s}function D(){const s=i.app.getPath("userData"),e=g.join(s,"schemas");return f("Config directory path:",e),e}async function p(){return j()}i.ipcMain.handle("read-file-sync",async(s,e)=>{o("IPC: read-file-sync called",{filename:e});try{const r=await n.promises.readFile(e,"utf-8"),t=JSON.parse(r);return o("File read successfully",{filename:e,contentLength:r.length}),t}catch(r){throw c("Failed to read file",{filename:e,error:r}),r}});i.ipcMain.handle("write-json-file",async(s,e,r)=>{o("write-json-file requested",{filePath:e,contentLength:r.length});try{const t=g.join(e,"..");try{await n.promises.access(t,n.constants.W_OK),f("Target directory is writable:",t)}catch(a){throw c("Target directory is not writable",{directory:t,error:a}),new Error(`Directory is not writable: ${t}`)}return await n.promises.writeFile(e,r,"utf8"),o("File written successfully:",e),{success:!0}}catch(t){return c("Failed to write file",{filePath:e,error:t instanceof Error?t.message:t,stack:t instanceof Error?t.stack:void 0}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});i.ipcMain.handle("get-config-directory",async()=>{o("get-config-directory requested");try{const s=await p();return o("Config directory ready:",s),{success:!0,path:s}}catch(s){return c("Failed to get config directory",s),{success:!1,error:s instanceof Error?s.message:"Unknown error"}}});i.ipcMain.handle("write-config-file",async(s,e,r)=>{o("write-config-file requested",{fileName:e,contentLength:r.length});try{const t=v(e);if(!t.isValid)return c("Invalid filename provided",{fileName:e,error:t.error}),{success:!1,error:t.error};if(typeof r!="string")return c("Invalid content type",{contentType:typeof r}),{success:!1,error:"Content must be a string"};if(r.length>10*1024*1024)return c("Content too large",{contentLength:r.length}),{success:!1,error:"Content is too large (maximum 10MB)"};const a=await p(),d=g.join(a,e);f("Writing config file",{configDir:a,fileName:e,filePath:d});try{await n.promises.access(d,n.constants.F_OK),f("File already exists, checking write permissions"),await n.promises.access(d,n.constants.W_OK)}catch{f("File does not exist, will create new file")}const l=`${d}.tmp`;try{await n.promises.writeFile(l,r,"utf8"),await n.promises.rename(l,d),o("Config file written successfully",{filePath:d,size:r.length})}catch(u){try{await n.promises.unlink(l)}catch{f("No temp file to clean up")}throw u}return{success:!0,filePath:d}}catch(t){return c("Failed to write config file",{fileName:e,error:t instanceof Error?t.message:t,stack:t instanceof Error?t.stack:void 0,code:t==null?void 0:t.code,errno:t==null?void 0:t.errno,syscall:t==null?void 0:t.syscall,path:t==null?void 0:t.path}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});i.ipcMain.handle("list-config-files",async()=>{o("list-config-files requested");try{const s=await p();f("Listing files in config directory:",s);const e=await n.promises.readdir(s);f("Found files:",e);const r=e.filter(a=>a.endsWith(".json")&&!a.endsWith(".tmp"));o("Found JSON files:",r);const t=await Promise.all(r.map(async a=>{const d=g.join(s,a);try{const l=await n.promises.readFile(d,"utf8"),u=JSON.parse(l);return f("Successfully read file:",{fileName:a,size:l.length}),{name:a,path:d,content:u}}catch(l){throw c("Failed to read or parse file",{fileName:a,error:l}),l}}));return o("Successfully loaded config files",{count:t.length}),{success:!0,files:t}}catch(s){return c("Failed to list config files",s),{success:!1,error:s instanceof Error?s.message:"Unknown error"}}});i.ipcMain.handle("show-open-dialog",async(s,e)=>{o("show-open-dialog requested",e);try{const r=await i.dialog.showOpenDialog(e);return f("Open dialog result:",r),r}catch(r){return c("Failed to show open dialog",r),{canceled:!0,filePaths:[]}}});i.ipcMain.handle("show-save-dialog",async(s,e)=>{o("show-save-dialog requested",e);try{const r=await i.dialog.showSaveDialog(e);return f("Save dialog result:",r),r}catch(r){return c("Failed to show save dialog",r),{canceled:!0,filePath:void 0}}});i.ipcMain.handle("delete-file",async(s,e)=>{o("delete-file requested",{filePath:e});try{return await n.promises.access(e,n.constants.F_OK),f("File exists, attempting to delete:",e),await n.promises.unlink(e),o("File deleted successfully:",e),{success:!0}}catch(r){return c("Failed to delete file",{filePath:e,error:r instanceof Error?r.message:r,code:r==null?void 0:r.code,errno:r==null?void 0:r.errno}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});i.ipcMain.handle("rename-file",async(s,e,r)=>{o("rename-file requested",{filePath:e,newFileName:r});try{const t=v(r);if(!t.isValid)return c("Invalid new filename provided for rename",{newFileName:r,error:t.error}),{success:!1,error:t.error};const a=r.endsWith(".json")?r:`${r}.json`;await n.promises.access(e,n.constants.F_OK);const d=g.dirname(e),l=g.join(d,a);try{return await n.promises.access(l,n.constants.F_OK),c("Target file already exists for rename",{targetPath:l}),{success:!1,error:"A file with the target name already exists"}}catch{}return await n.promises.rename(e,l),o("File renamed successfully",{from:e,to:l}),{success:!0,newPath:l,newName:a}}catch(t){return c("Failed to rename file",{filePath:e,newFileName:r,error:t}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});i.ipcMain.handle("create-schema-json-directory",async(s,e)=>{o("create-schema-json-directory requested",{schemaName:e});try{const r=await p(),t=g.join(r,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));return await n.promises.mkdir(t,{recursive:!0}),o("Schema JSON directory created/verified:",t),{success:!0,path:t}}catch(r){return c("Failed to create schema JSON directory",{schemaName:e,error:r}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});i.ipcMain.handle("write-schema-json-file",async(s,e,r,t)=>{o("write-schema-json-file requested",{schemaName:e,fileName:r,contentLength:t.length});try{const a=await p(),d=g.join(a,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));await n.promises.mkdir(d,{recursive:!0});const l=r.endsWith(".json")?r:`${r}.json`,u=g.join(d,l);return await n.promises.writeFile(u,t,"utf8"),o("Schema JSON file written successfully:",u),{success:!0,filePath:u}}catch(a){return c("Failed to write schema JSON file",{schemaName:e,fileName:r,error:a}),{success:!1,error:a instanceof Error?a.message:"Unknown error"}}});i.ipcMain.handle("list-schema-json-files",async(s,e)=>{o("list-schema-json-files requested",{schemaName:e});try{const r=await p(),t=g.join(r,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));try{await n.promises.access(t,n.constants.F_OK)}catch{return o("Schema directory does not exist, returning empty list:",t),{success:!0,files:[]}}const d=(await n.promises.readdir(t)).filter(u=>u.endsWith(".json")),l=await Promise.all(d.map(async u=>{const w=g.join(t,u);try{const h=await n.promises.readFile(w,"utf8"),F=JSON.parse(h);return{name:u,path:w,content:F}}catch(h){throw c("Failed to read schema JSON file",{fileName:u,error:h}),h}}));return o("Successfully loaded schema JSON files",{schemaName:e,count:l.length}),{success:!0,files:l}}catch(r){return c("Failed to list schema JSON files",{schemaName:e,error:r}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});i.app.whenReady().then(()=>{o("App is ready, creating main window"),y(),o("System information",{platform:process.platform,arch:process.arch,version:process.version,electronVersion:process.versions.electron,userDataPath:i.app.getPath("userData"),tempPath:i.app.getPath("temp"),homePath:i.app.getPath("home")}),i.app.on("activate",()=>{i.BrowserWindow.getAllWindows().length===0&&(o("Reactivating app, creating new window"),y())})});i.app.on("window-all-closed",()=>{o("All windows closed"),process.platform!=="darwin"&&(o("Quitting app"),i.app.quit())});i.app.on("web-contents-created",(s,e)=>{e.on("new-window",(r,t)=>{r.preventDefault(),c("Blocked new window creation",{url:t})})});

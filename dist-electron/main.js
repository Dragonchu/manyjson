"use strict";const o=require("electron"),g=require("path"),i=require("fs"),m=process.env.NODE_ENV==="development";function n(s,...e){console.log(`[INFO] ${new Date().toISOString()} - ${s}`,...e)}function c(s,e){console.error(`[ERROR] ${new Date().toISOString()} - ${s}`,e)}function u(s,...e){m&&console.log(`[DEBUG] ${new Date().toISOString()} - ${s}`,...e)}function v(s){if(!s||typeof s!="string")return{isValid:!1,error:"Filename is required and must be a string"};const e=s.trim();return e?e.includes("..")||e.includes("/")||e.includes("\\")?{isValid:!1,error:"Filename cannot contain path separators or relative path references"}:/[<>:"|?*\x00-\x1f]/.test(e)?{isValid:!1,error:"Filename contains invalid characters"}:Buffer.byteLength(e,"utf8")>255?{isValid:!1,error:"Filename is too long"}:/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i.test(e)?{isValid:!1,error:"Filename uses a reserved name"}:{isValid:!0}:{isValid:!1,error:"Filename cannot be empty"}}async function D(s=3){const e=j();for(let r=1;r<=s;r++)try{u(`Ensuring config directory exists (attempt ${r}/${s}):`,e);try{await i.promises.access(e,i.constants.F_OK),u("Config directory already exists")}catch{n("Creating config directory:",e),await i.promises.mkdir(e,{recursive:!0}),n("Config directory created successfully")}try{return await i.promises.access(e,i.constants.W_OK),u("Config directory is writable"),e}catch(t){throw c("Config directory is not writable",t),new Error(`Config directory is not writable: ${e}`)}}catch(t){if(c(`Failed to create or access config directory (attempt ${r}/${s})`,t),r===s)throw t;await new Promise(a=>setTimeout(a,100*r))}throw new Error("Failed to ensure config directory after all retries")}function y(){const s=new o.BrowserWindow({width:1200,height:800,minWidth:1e3,minHeight:700,title:"ManyJson - JSON Schema Manager",backgroundColor:o.nativeTheme.shouldUseDarkColors?"#0a0a0a":"#ffffff",webPreferences:{preload:g.join(__dirname,"preload.js"),contextIsolation:!0,sandbox:!0,nodeIntegration:!1}});if(m)s.loadURL("http://localhost:5173"),s.webContents.openDevTools();else{const e=g.join(__dirname,"../dist/index.html");n("Loading HTML file from:",e),s.loadFile(e).catch(r=>{c("Failed to load HTML file",{htmlPath:e,error:r}),s.webContents.openDevTools()})}return s}function j(){const s=o.app.getPath("userData"),e=g.join(s,"schemas");return u("Config directory path:",e),e}async function h(){return D()}o.ipcMain.handle("read-file-sync",async(s,e)=>{n("IPC: read-file-sync called",{filename:e});try{const r=await i.promises.readFile(e,"utf-8"),t=JSON.parse(r);return n("File read successfully",{filename:e,contentLength:r.length}),t}catch(r){throw c("Failed to read file",{filename:e,error:r}),r}});o.ipcMain.handle("write-json-file",async(s,e,r)=>{n("write-json-file requested",{filePath:e,contentLength:r.length});try{const t=g.join(e,"..");try{await i.promises.access(t,i.constants.W_OK),u("Target directory is writable:",t)}catch(a){throw c("Target directory is not writable",{directory:t,error:a}),new Error(`Directory is not writable: ${t}`)}return await i.promises.writeFile(e,r,"utf8"),n("File written successfully:",e),{success:!0}}catch(t){return c("Failed to write file",{filePath:e,error:t instanceof Error?t.message:t,stack:t instanceof Error?t.stack:void 0}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});o.ipcMain.handle("get-config-directory",async()=>{n("get-config-directory requested");try{const s=await h();return n("Config directory ready:",s),{success:!0,path:s}}catch(s){return c("Failed to get config directory",s),{success:!1,error:s instanceof Error?s.message:"Unknown error"}}});o.ipcMain.handle("write-config-file",async(s,e,r)=>{n("write-config-file requested",{fileName:e,contentLength:r.length});try{const t=v(e);if(!t.isValid)return c("Invalid filename provided",{fileName:e,error:t.error}),{success:!1,error:t.error};if(typeof r!="string")return c("Invalid content type",{contentType:typeof r}),{success:!1,error:"Content must be a string"};if(r.length>10*1024*1024)return c("Content too large",{contentLength:r.length}),{success:!1,error:"Content is too large (maximum 10MB)"};const a=await h(),l=g.join(a,e);u("Writing config file",{configDir:a,fileName:e,filePath:l});try{await i.promises.access(l,i.constants.F_OK),u("File already exists, checking write permissions"),await i.promises.access(l,i.constants.W_OK)}catch{u("File does not exist, will create new file")}const f=`${l}.tmp`;try{await i.promises.writeFile(f,r,"utf8"),await i.promises.rename(f,l),n("Config file written successfully",{filePath:l,size:r.length})}catch(d){try{await i.promises.unlink(f)}catch{u("No temp file to clean up")}throw d}return{success:!0,filePath:l}}catch(t){return c("Failed to write config file",{fileName:e,error:t instanceof Error?t.message:t,stack:t instanceof Error?t.stack:void 0,code:t==null?void 0:t.code,errno:t==null?void 0:t.errno,syscall:t==null?void 0:t.syscall,path:t==null?void 0:t.path}),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}});o.ipcMain.handle("list-config-files",async()=>{n("list-config-files requested");try{const s=await h();u("Listing files in config directory:",s);const e=await i.promises.readdir(s);u("Found files:",e);const r=e.filter(a=>a.endsWith(".json")&&!a.endsWith(".tmp"));n("Found JSON files:",r);const t=await Promise.all(r.map(async a=>{const l=g.join(s,a);try{const f=await i.promises.readFile(l,"utf8"),d=JSON.parse(f);return u("Successfully read file:",{fileName:a,size:f.length}),{name:a,path:l,content:d}}catch(f){throw c("Failed to read or parse file",{fileName:a,error:f}),f}}));return n("Successfully loaded config files",{count:t.length}),{success:!0,files:t}}catch(s){return c("Failed to list config files",s),{success:!1,error:s instanceof Error?s.message:"Unknown error"}}});o.ipcMain.handle("show-open-dialog",async(s,e)=>{n("show-open-dialog requested",e);try{const r=await o.dialog.showOpenDialog(e);return u("Open dialog result:",r),r}catch(r){return c("Failed to show open dialog",r),{canceled:!0,filePaths:[]}}});o.ipcMain.handle("show-save-dialog",async(s,e)=>{n("show-save-dialog requested",e);try{const r=await o.dialog.showSaveDialog(e);return u("Save dialog result:",r),r}catch(r){return c("Failed to show save dialog",r),{canceled:!0,filePath:void 0}}});o.ipcMain.handle("delete-file",async(s,e)=>{n("delete-file requested",{filePath:e});try{return await i.promises.access(e,i.constants.F_OK),u("File exists, attempting to delete:",e),await i.promises.unlink(e),n("File deleted successfully:",e),{success:!0}}catch(r){return c("Failed to delete file",{filePath:e,error:r instanceof Error?r.message:r,code:r==null?void 0:r.code,errno:r==null?void 0:r.errno}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});o.ipcMain.handle("create-schema-json-directory",async(s,e)=>{n("create-schema-json-directory requested",{schemaName:e});try{const r=await h(),t=g.join(r,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));return await i.promises.mkdir(t,{recursive:!0}),n("Schema JSON directory created/verified:",t),{success:!0,path:t}}catch(r){return c("Failed to create schema JSON directory",{schemaName:e,error:r}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});o.ipcMain.handle("write-schema-json-file",async(s,e,r,t)=>{n("write-schema-json-file requested",{schemaName:e,fileName:r,contentLength:t.length});try{const a=await h(),l=g.join(a,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));await i.promises.mkdir(l,{recursive:!0});const f=r.endsWith(".json")?r:`${r}.json`,d=g.join(l,f);return await i.promises.writeFile(d,t,"utf8"),n("Schema JSON file written successfully:",d),{success:!0,filePath:d}}catch(a){return c("Failed to write schema JSON file",{schemaName:e,fileName:r,error:a}),{success:!1,error:a instanceof Error?a.message:"Unknown error"}}});o.ipcMain.handle("list-schema-json-files",async(s,e)=>{n("list-schema-json-files requested",{schemaName:e});try{const r=await h(),t=g.join(r,"json-files",e.replace(/[^a-zA-Z0-9.-]/g,"_"));try{await i.promises.access(t,i.constants.F_OK)}catch{return n("Schema directory does not exist, returning empty list:",t),{success:!0,files:[]}}const l=(await i.promises.readdir(t)).filter(d=>d.endsWith(".json")),f=await Promise.all(l.map(async d=>{const w=g.join(t,d);try{const p=await i.promises.readFile(w,"utf8"),F=JSON.parse(p);return{name:d,path:w,content:F}}catch(p){throw c("Failed to read schema JSON file",{fileName:d,error:p}),p}}));return n("Successfully loaded schema JSON files",{schemaName:e,count:f.length}),{success:!0,files:f}}catch(r){return c("Failed to list schema JSON files",{schemaName:e,error:r}),{success:!1,error:r instanceof Error?r.message:"Unknown error"}}});o.app.whenReady().then(()=>{n("App is ready, creating main window"),y(),n("System information",{platform:process.platform,arch:process.arch,version:process.version,electronVersion:process.versions.electron,userDataPath:o.app.getPath("userData"),tempPath:o.app.getPath("temp"),homePath:o.app.getPath("home")}),o.app.on("activate",()=>{o.BrowserWindow.getAllWindows().length===0&&(n("Reactivating app, creating new window"),y())})});o.app.on("window-all-closed",()=>{n("All windows closed"),process.platform!=="darwin"&&(n("Quitting app"),o.app.quit())});o.app.on("web-contents-created",(s,e)=>{e.on("new-window",(r,t)=>{r.preventDefault(),c("Blocked new window creation",{url:t})})});
